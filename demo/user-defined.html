<!doctype html>

<meta charset="utf-8">
<title>Dagre D3 Demo: User-defined Shapes and Arrows</title>

<link rel="stylesheet" href="demo.css">
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="../dist/dagre-d3.js"></script>

<style id="css">
body {
  font: 300 14px 'Helvetica Neue', Helvetica;
}

.node line,
.node rect,
.node circle,
.node ellipse,
.node polygon {
  stroke: #333;
  fill: #fff;
  stroke-width: 1.5px;
}

.edgePath path.path {
  stroke: #333;
  fill: none;
  stroke-width: 1.5px;
}
</style>

<h1>Dagre D3 Demo: User-defined Shapes and Arrows</h1>

<svg width=960 height=600><g/></svg>

<section>
<p>An example that shows how to create and use user-defined shapes and arrows.
</section>

<script id="js">
// Create a new directed graph
var g = new dagreD3.graphlib.Graph().setGraph({});

g.setNode("fail", { shape: "fail", label: "house" });
g.setNode("rect", { shape: "rect" });
g.setEdge("fail", "rect", { arrowhead: "hollowPoint" });

var svg = d3.select("svg"),
    inner = svg.select("g");

// Set up zoom support
var zoom = d3.behavior.zoom().on("zoom", function() {
    inner.attr("transform", "translate(" + d3.event.translate + ")" +
                                "scale(" + d3.event.scale + ")");
  });
svg.call(zoom);

// Create the renderer
var render = new dagreD3.render();

// Add our custom shape (a house)
render.shapes().house = function(parent, bbox, node) {
  var w = bbox.width,
      h = bbox.height,
      points = [
        { x:   0, y:        0 },
        { x:   w, y:        0 },
        //{ x:   w, y:       -h },
        //{ x: w/2, y: -h * 3/2 },
        //{ x:   0, y:       -h }
        { x: w/2, y: -h * 1 },
        { x:   0, y:       0 }
      ];
      shapeSvg = parent.insert("polygon", ":first-child")
        .attr("points", points.map(function(d) { return d.x + "," + d.y; }).join(" "))
        .attr("transform", "translate(" + (-w/2) + "," + (h * 3/4) + ")");

  node.intersect = function(point) {
    return dagreD3.intersect.polygon(node, points, point);
  };

  return shapeSvg;
};

// Fork
render.shapes().fork = function(parent, bbox, node) {
  var w = bbox.width,
      h = bbox.height,
      points = [
        { x:   0, y:  h/2 },
        { x:   w, y:  h/2 },
        { x: w/2, y:  -h/2 },
        { x:   0, y:  h/2 }
      ];
      shapeSvg = parent.insert("polygon", ":first-child")
        .attr("points", points.map(function(d) { return d.x + "," + d.y; }).join(" "))
        .attr("transform", "translate(" + (-w/2) + "," + (h * 3/4) + ")");

  node.intersect = function(point) {
    return dagreD3.intersect.polygon(node, points, point);
  };

  return shapeSvg;
};


// Join
render.shapes().join = function(parent, bbox, node) {
  var w = bbox.width,
      h = bbox.height,
      points = [
        { x:   0, y:  -h/2 },
        { x:   w, y:  -h/2 },
        { x: w/2, y:  h/2 },
        { x:   0, y:  -h/2 }
      ];
      shapeSvg = parent.insert("polygon", ":first-child")
        .attr("points", points.map(function(d) { return d.x + "," + d.y; }).join(" "))
        .attr("transform", "translate(" + (-w/2) + "," + (h * 3/4) + ")");

  node.intersect = function(point) {
    return dagreD3.intersect.polygon(node, points, point);
  };

  return shapeSvg;
};

// Decision
render.shapes().decision = function(parent, bbox, node) {
  var w = bbox.width,
      h = bbox.height,
      points = [
        { x:   0,   y:  0 },
        { x:   w/2, y:  -h/2 },
        { x:   w, y:  0 },
        { x: w/2, y:  h/2 },
        { x:   0, y:  0 }
      ];
      shapeSvg = parent.insert("polygon", ":first-child")
        .attr("points", points.map(function(d) { return d.x + "," + d.y; }).join(" "))
        .attr("transform", "translate(" + (-w/2) + "," + (h * 3/4) + ")");

  node.intersect = function(point) {
    return dagreD3.intersect.polygon(node, points, point);
  };

  return shapeSvg;
};

// Switch
render.shapes().switch = function(parent, bbox, node) {
  var w = bbox.width,
      h = bbox.height,
      points = [
        { x:   0,   y:  0 },
        { x:   w/2, y:  -h/2 },
        { x:   w, y:  0 },
        { x: w/2, y:  h/2 },
        { x:   0, y:  0 },
        { x:   w, y:  0 }
      ];
      shapeSvg = parent.insert("polygon", ":first-child")
        .attr("points", points.map(function(d) { return d.x + "," + d.y; }).join(" "))
        .attr("transform", "translate(" + (-w/2) + "," + (h * 3/4) + ")");

  node.intersect = function(point) {
    return dagreD3.intersect.polygon(node, points, point);
  };

  return shapeSvg;
};

// Case
render.shapes().case = function(parent, bbox, node) {
  var w = bbox.width,
      h = bbox.height,
      points = [
        { x:   0,   y:  0 },
        { x:   w/3, y:  -h/2 },
        { x:   2*w/3, y:  -h/2 },
        { x:   w, y:  0 },
        { x:   2*w/3, y:  h/2 },
        { x:   w/3, y:  h/2 },
        { x:   0, y:  0 }
      ];
      shapeSvg = parent.insert("polygon", ":first-child")
        .attr("points", points.map(function(d) { return d.x + "," + d.y; }).join(" "))
        .attr("transform", "translate(" + (-w/2) + "," + (h * 3/4) + ")");

  node.intersect = function(point) {
    return dagreD3.intersect.polygon(node, points, point);
  };

  return shapeSvg;
};

// Sub-Workflow
render.shapes().subworkflow = function(parent, bbox, node) {
  var w = bbox.width,
      h = bbox.height,
      points = [
        { x:   0,   y:  0 },
        { x:   0,   y:  -h/2 },
        { x:   w,   y:  -h/2 },
        { x:   w,   y:  h/2 },
        { x:   0,   y:  h/2 },
        { x:   0, y:  h/3 },
        { x:   w, y:  h/3 },
        { x:   0, y:  h/3 },
        { x:   0, y:  0 }
      ];
      shapeSvg = parent.insert("polygon", ":first-child")
        .attr("points", points.map(function(d) { return d.x + "," + d.y; }).join(" "))
        .attr("transform", "translate(" + (-w/2) + "," + (h * 3/4) + ")");

  node.intersect = function(point) {
    return dagreD3.intersect.polygon(node, points, point);
  };

  return shapeSvg;
};

// Start
render.shapes().start = function(parent, bbox, node) {
  var w = bbox.width,
      h = bbox.height,
      points = [
        { x:   h/3,       y:  -h/2 },
        { x:   w-h/3,     y:  -h/2 },
        { x:   w-h/3,     y:  h/2 },
        { x:   h/3,       y:  h/2 }
      ];
      
      shapeSvg = parent.insert("polygon", ":first-child")
        .attr("points", points.map(function(d) { return d.x + "," + d.y; }).join(" "))
        .attr("transform", "translate(" + (-w/2) + "," + (h * 3/4) + ")");

      shapeSvg = parent.insert("rect", ":first-child")
        .attr({
          "x": 0,
          "y": -h/2,
          "width": w,
          "height": h,
          "rx": h/3,
          "ry": h/3
        })
        .attr("transform", "translate(" + (-w/2) + "," + (h * 3/4) + ")")

  node.intersect = function(point) {
    return dagreD3.intersect.polygon(node, points, point);
  };

  return shapeSvg;
};

// End
render.shapes().end = function(parent, bbox, node) {
  var w = bbox.width,
      h = bbox.height;
      shapeSvg = parent.insert("rect", ":first-child")
        .attr({
          "x": 0,
          "y": -h/2,
          "width": w,
          "height": h,
          "rx": h/2.5,
          "ry": h/2.5
        })
        .attr("transform", "translate(" + (-w/2) + "," + (h * 3/4) + ")");

  node.intersect = function(point) {
    return dagreD3.intersect.rect(node, point);
  };

  return shapeSvg;
};

// Fail
render.shapes().fail = function(parent, bbox, node) {
  var w = bbox.width,
      h = bbox.height,
      r = w > h ? h/2 : w/2,
      d = w > h ? h : w,
      e = Math.sqrt(2)*r;


      shapeSvg = parent.insert("line", ":first-child")
        .attr({
          "x1": r*.25,
          "y1": -d/3,
          "x2": d-r*.25,
          "y2": d/3
        })
        .attr("transform", "translate(" + (-d/2) + "," + (h * 3/4) + ")");

      shapeSvg = parent.insert("line", ":first-child")
        .attr({
          "x2": d-r*.25,
          "y2": -d/3,
          "x1": r*.25,
          "y1": d/3
        })
        .attr("transform", "translate(" + (-d/2) + "," + (h * 3/4) + ")");


      shapeSvg = parent.insert("circle", ":first-child")
        .attr({
          "cx": d/2,
          "cy": 0,
          "r": r
        })
        .attr("transform", "translate(" + (-d/2) + "," + (h * 3/4) + ")")

  node.intersect = function(point) {
    return dagreD3.intersect.circle(node, r,point);
  };

  return shapeSvg;
};

// Add our custom arrow (a hollow-point)
render.arrows().hollowPoint = function normal(parent, id, edge, type) {
  var marker = parent.append("marker")
    .attr("id", id)
    .attr("viewBox", "0 0 10 10")
    .attr("refX", 9)
    .attr("refY", 5)
    .attr("markerUnits", "strokeWidth")
    .attr("markerWidth", 8)
    .attr("markerHeight", 6)
    .attr("orient", "auto");

  var path = marker.append("path")
    .attr("d", "M 0 0 L 10 5 L 0 10 z")
    .style("stroke-width", 1)
    .style("stroke-dasharray", "1,0")
    .style("fill", "#fff")
    .style("stroke", "#333");
  dagreD3.util.applyStyle(path, edge[type + "Style"]);
};

// Run the renderer. This is what draws the final graph.
render(inner, g);

// Center the graph
var initialScale = 0.75;
zoom
  .translate([(svg.attr("width") - g.graph().width * initialScale) / 2, 20])
  .scale(initialScale)
  .event(svg);
svg.attr('height', g.graph().height * initialScale + 40);
</script>

<script src="demo.js"></script>
